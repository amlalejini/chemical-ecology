#pragma once

#include <functional>
#include <map>
#include <iostream>
#include <string>
#include <algorithm>

#include "emp/bits/BitVector.hpp"
#include "emp/base/vector.hpp"
#include "emp/datastructs/vector_utils.hpp"
#include "emp/tools/string_utils.hpp"
#include "emp/functional/FunctionSet.hpp"

#include "chemical-ecology/CommunityStructure.hpp"
#include "chemical-ecology/RecordedCommunitySummarizer.hpp"

namespace chemical_ecology {

// Forward declarations
struct RecordedCommunitySummary;
class RecordedCommunitySummarizer;

// TODO - make class, protect member variables?
struct RecordedCommunitySummary {
  emp::vector<double> counts;               // Species counts - this should uniquely identify this community (in the context of a RecordedCommunitySet)
  emp::vector<size_t> present_species_ids;  // List of species IDs present in this recorded community
  emp::BitVector present;                   // BitVector describing presence/absence of each species
  // NOTE: as per slack conversation, we might want to rename 'present_no_interactions'
  emp::BitVector present_no_interactions;   // Species present without interactions with *OTHER* species

  emp::vector<size_t> complete_subcommunities_present; // IDs of complete subcommunity structures present in this recorded community
                                                       //   IDs come from given CommunityStructure instance
  emp::vector<size_t> partial_subcommunities_present;  // IDs of partial subcommunity structures present in this recorded community
                                                       //   IDs come from given CommunityStructure instance
  emp::vector<double> proportion_subcommunity_present; // Proportion of each subcommunity structure present in recorded community

  bool operator<(const RecordedCommunitySummary& other) const {
    return counts < other.counts;
  }

  void Reset(size_t num_members=0) {
    (present.Resize(num_members)).Clear();
    (present_no_interactions.Resize(num_members)).Clear();
    present_species_ids.clear();
    counts.clear();
    counts.resize(num_members, 0);
    complete_subcommunities_present.clear();
    partial_subcommunities_present.clear();
    proportion_subcommunity_present.clear();
  }

  // Get number of distinct species present in this summarized community
  size_t GetNumSpeciesPresent() const { return present_species_ids.size(); }

  size_t GetPopulationSize() const {
    return emp::Sum(counts);
  }

  size_t GetNumCompleteSubCommunities() const {
    return complete_subcommunities_present.size();
  }

  // "Pretty" print the summary in a human-readable format
  void Print(std::ostream & os=std::cout, const std::string& prefix = "") const {
    os << prefix << "Community composition: ";
    emp::Print(counts, os);
    os << std::endl;
    os << prefix << "Present: " << present << std::endl;
    os << prefix << "Present (no interactions): " << present_no_interactions << std::endl;
    os << prefix << "Subcommunities present (\% of subcommunity): ";
    emp::Print(proportion_subcommunity_present, os);
    os << std::endl;
  }
};

// Generates instances of RecordedCommunitySummary from vectors of species counts
//  At the moment summarizer forces configuration on construction ==> this helps to
//  make sure that all summaries generated by a particular instance of a summarizer
//  were generated in the same way
class RecordedCommunitySummarizer {
public:
  using is_present_fun_t = std::function<bool(double)>;
  using summary_update_fun_t = std::function<RecordedCommunitySummary(
    const RecordedCommunitySummarizer&,
    const RecordedCommunitySummary&
  )>;

protected:
  const CommunityStructure& community_structure;
  is_present_fun_t is_present_fun;
  emp::vector<summary_update_fun_t> summary_update_functions;

public:
  RecordedCommunitySummarizer(
    const CommunityStructure& structure,
    is_present_fun_t is_present,
    const emp::vector<summary_update_fun_t>& update_funs = {}
  ) :
    community_structure(structure),
    is_present_fun(is_present),
    summary_update_functions(update_funs)
  { }

  emp::vector<RecordedCommunitySummary> SummarizeAll(
    const emp::vector<emp::vector<double>>& cells,
    bool apply_update_functions=true
  ) const {
    emp::vector<RecordedCommunitySummary> summaries;
    for (size_t i = 0; i < cells.size(); ++i) {
      summaries.emplace_back(
        Summarize(
          cells[i],
          apply_update_functions
        )
      );
    }
    return summaries;
  }

  RecordedCommunitySummary Summarize(
    const emp::vector<double>& member_counts,
    bool apply_update_functions=true
  ) const {
    // Create a new community summary
    RecordedCommunitySummary summary;
    const size_t num_members = member_counts.size();
    summary.Reset(num_members);
    emp_assert(summary.counts.size() == member_counts.size());

    // Process counts
    for (size_t mem_i = 0; mem_i < num_members; ++mem_i) {
      // Drops fractional component of number
      summary.counts[mem_i] = std::trunc(member_counts[mem_i]);
      // Fingerprint present/absence
      summary.present[mem_i] = is_present_fun(summary.counts[mem_i]);
      if (summary.present[mem_i]) {
        summary.present_species_ids.emplace_back(mem_i);
      }
    }

    // Identify members that are present with no interactions (with *OTHER* members)
    for (size_t mem_i : summary.present_species_ids) {
      emp_assert(summary.present[mem_i]);
      const size_t member_comm_id = community_structure.GetSubCommunityID(mem_i);
      const auto& subcommunity = community_structure.GetSubCommunity(member_comm_id);
      emp_assert(emp::Has(subcommunity, mem_i));
      // Does this member species have other species present that share a community?
      // - For each other species in this species' subcommunity, are any present?
      bool interacts = false;
      for (size_t other_id : subcommunity) {
        if (other_id != mem_i && summary.present[other_id]) {
          interacts = true;
          break;
        }
      }
      summary.present_no_interactions[mem_i] = !interacts;
    }

    // Identify number of complete and partial subcommunities present
    summary.proportion_subcommunity_present.resize(community_structure.GetNumSubCommunities(), 0.0);
    // const size_t num_present = present_species_ids.size();
    const auto& subcomm_fingerprints = community_structure.GetFingerprints();
    for (size_t comm_id = 0; comm_id < community_structure.GetNumSubCommunities(); ++comm_id) {
      const auto& subcomm_fingerprint = subcomm_fingerprints[comm_id];
      const emp::BitVector result = summary.present & subcomm_fingerprint;
      const size_t shared_overlap = result.CountOnes();
      if (shared_overlap > 0) {
        summary.partial_subcommunities_present.emplace_back(comm_id);
      }
      // shared_overlap can't be larger than subcommunity size or number of present species
      emp_assert(shared_overlap <= community_structure.GetNumMembers(comm_id));
      emp_assert(shared_overlap <= summary.present_species_ids.size());
      if (shared_overlap == community_structure.GetNumMembers(comm_id)) {
        summary.complete_subcommunities_present.emplace_back(comm_id);
      }
      summary.proportion_subcommunity_present[comm_id] = (double)shared_overlap / (double)community_structure.GetNumMembers(comm_id);
    }

    // Apply any summary update functions in sequential order
    if (apply_update_functions) {
      for (size_t fun_i = 0; fun_i < summary_update_functions.size(); ++fun_i) {
        summary = summary_update_functions[fun_i](*this, summary);
      }
    }

    return summary;
  }
}; // End RecordedCommunitySummarizer definition

// Returns new summary with present-with-no-interactions species removed.
RecordedCommunitySummary RemovePresentNoInteractions(
  const RecordedCommunitySummarizer& summarizer,
  const RecordedCommunitySummary& in_summary
) {
  // Create new counts vector from given counts. Zero out all present no interaction species.
  emp::vector<double> new_counts(in_summary.counts);
  for (size_t species_i = 0; species_i < new_counts.size(); ++species_i) {
    new_counts[species_i] = (in_summary.present_no_interactions[species_i]) ? 0 : new_counts[species_i];
  }
  return summarizer.Summarize(new_counts, false);
}

} // End chemical_ecology namespace